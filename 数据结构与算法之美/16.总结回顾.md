 # 算法基本模板

 ## 递归算法基本结构

 ```ts
 function recursion(params):ReturnType {
  // 1.递归终止条件
  if(满足条件) {
    return 结果
  }

  // 2.当前层的逻辑（可选）
  // 做一些处理

  // 3.递归调用进入下一层
  const result1 = recursion(子问题1)
  const result2 = recursion(子问题2)
  
  // 4.返回本层
  return 合并(result1,result2)
 }
 ```

 ## DFS递归写法（搜索/回溯）

适合树/图搜索、组合排列：

 ```ts
 function dfs(node,path) {
  if(到达叶子节点或者边界) {
    收集结果(path)
    return
  }

  for(选择 of 可选项){
    path.push(选择)
    dfs(下一个节点,path)
    path.pop() // 回溯
  }
 }
 ```

 ## BFS算法模板

 常用于：最短路径（无权图）；层序遍历（树、图）；状态搜索（棋盘、迷宫、字符串变换）

 ```ts
function bfs(root: TreeNode | null): number[][] {
  if (!root) return []
  const queue: TreeNode[] = [root]
  const res: number[][] = []

  while (queue.length > 0) {
    const size = queue.length
    const level: number[] = []

    for (let i = 0; i < size; i++) {
      const node = queue.shift()!
      level.push(node.val)  

      if (node.left) queue.push(node.left)
      if (node.right) queue.push(node.right)
    }

    res.push(level)
  }

  return res
}
 ```

## 二分查找模板
适合“有序区间里找目标”或“单调性判定”的问题。它的难点在于边界（left/right 的取值、mid 的计算、循环退出条件）。

```ts
function binarySearch(nums:number[],target:number){
  let left = 0, right = nums.length - 1

  while(left<=right){
    const mid = left + (right - left) >> 2

    if(nums[mid] === target){
      return mid
    }else if (nums[mid] < target){
      left = mid + 1
    }else {
      right = mid -1
    }
  }

  return -1 // 没找到
}
```

## 动态规划

### 一维dp模板
常见于「爬楼梯」「打家劫舍」「斐波那契」这类线性问题。

```ts
function dp(n:number) {
  const dp  = new Array(n + 1).fill(0)

  // 初始化条件
  dp[0] = 0
  dp[1] = 1

  // 状态转移
  for(let i = 2; i <= n; i++) {
    // 状态转移方程
    dp[i] = dp[i - 1] + dp[i - 2]  
  }

  return dp[n]
}
```

### 二维dp模板
常见于「路径问题」「背包问题」「编辑距离」。

```ts
function dp(m: number, n: number): number {
  const dp = Array.from({ length: m }, () => Array(n).fill(0))

  // 初始化（第一行 / 第一列）
  for (let i = 0; i < m; i++) dp[i][0] = 1
  for (let j = 0; j < n; j++) dp[0][j] = 1

  // 状态转移
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
    }
  }

  return dp[m - 1][n - 1]
}
```

## 位运算操作

```ts
// 判断奇偶
X & 1 == 1 OR == 0  
X % 2 == 1

// 清零最低位的1
X = X & (X - 1) 

// 得到最低位的1
X & -X
```